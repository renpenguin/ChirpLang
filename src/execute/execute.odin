package execute

import p "../parser"
import s "../scope"
import t "../tokeniser"
import "core:fmt"
import "core:strings"

STACK_LIMIT :: 500

ReturnHandler :: enum {
	DontHandle, // Parent scope can deal with this || no return value
	Loop, // Handle break and continue
	Function, // Handle return
}
ReturnState :: struct {
	handle_by: ReturnHandler,
	contents:  union {
		p.LoopControl, // For .Loop
		p.Value, // For .Function
	},
}
NoReturn :: ReturnState{}

execute_block :: proc(block: p.Block, scope: ^s.Scope) -> (returned := NoReturn, err: RuntimeError = NoErrorUnit) {
	using p

	iter_instructions: for instruction in block {
		switch inst in instruction {
		case VariableDefinition:
			contents: p.Value
			contents, err = execute_expression(inst.expr, scope)
			if !is_runtime_error_ok(err) do return

			to_assign := s.Variable{inst.name, contents, inst.mutable}
			for var, i in scope.constants { 	// Redefining existing variables
				if var.name != inst.name do continue
				scope.constants[i] = to_assign
				continue iter_instructions
			}
			append(&scope.constants, to_assign)
		case VariableAssignment:
			err = assign_operation(inst, scope)
			if !is_runtime_error_ok(err) do return
		case While:
			for {
				result: bool
				result, err = evaluate_condition_expression(inst.condition, scope)
				if !is_runtime_error_ok(err) do return
				if !result do break

				while_scope := new(s.Scope)
				defer s.destroy_scope(while_scope)
				while_scope.parent_scope = scope

				while_return, while_err := execute_block(inst.block, while_scope)
				if !is_runtime_error_ok(while_err) do return NoReturn, while_err
				if returned.handle_by == .Function do return while_return, while_err
				if while_return.contents == .Break do break
			}
		case IfStatement:
			returned, err = execute_if_statement(inst, scope)
			if !is_runtime_error_ok(err) do return
			if returned.handle_by != .DontHandle do return
		case Expression:
			_, err = execute_expression(inst, scope)
			if !is_runtime_error_ok(err) do return NoReturn, err
		case Return:
			returned.handle_by = .Function
			returned.contents, err = execute_expression(Expression(inst), scope)
			return
		case LoopControl:
			returned.handle_by = .Loop
			returned.contents = inst
			return

		case ImportStatement, FunctionDefinition:
			break // Ignore
		}
	}

	return
}

@(private)
evaluate_condition_expression :: proc(
	expr: p.Expression,
	scope: ^s.Scope,
) -> (
	result: bool,
	err: RuntimeError = NoErrorUnit,
) {
	condition_value: p.Value
	condition_value, err = execute_expression(expr, scope)
	if !is_runtime_error_ok(err) do return

	is_bool: bool
	result, is_bool = condition_value.(bool)
	return
}

@(private)
execute_if_statement :: proc(
	if_statement: p.IfStatement,
	parent_scope: ^s.Scope,
) -> (
	returned := NoReturn,
	err: RuntimeError = NoErrorUnit,
) {
	result: bool
	result, err = evaluate_condition_expression(if_statement.condition, parent_scope)
	if !is_runtime_error_ok(err) do return

	if result {
		if_scope := new(s.Scope)
		defer s.destroy_scope(if_scope)
		if_scope.parent_scope = parent_scope

		returned, err = execute_block(if_statement.true_block, if_scope) // This writes directly to the return value
	} else {
		switch branch in if_statement.else_branch {
		case ^p.IfStatement:
			returned, err = execute_if_statement(branch^, parent_scope) // So does this

		case p.Block:
			else_scope := new(s.Scope)
			defer s.destroy_scope(else_scope)
			else_scope.parent_scope = parent_scope

			returned, err = execute_block(branch, else_scope) // and this
		}
	}
	return // Any errors generated by any of the branches will be returned here
}

@(private)
execute_expression :: proc(
	expression: p.Expression,
	scope: ^s.Scope,
) -> (
	value: p.Value = p.None,
	err: RuntimeError = NoErrorUnit,
) {
	using p

	switch expr in expression {
	case FunctionCall:
		return call_function(expr, scope)
	case Operation:
		value1, value2: Value
		value1, err = execute_expression(expr.left^, scope)
		if !is_runtime_error_ok(err) do return
		value2, err = execute_expression(expr.right^, scope)
		if !is_runtime_error_ok(err) do return

		return process_operation(value1, value2, expr.op)
	case FormatString:
		sb := strings.builder_make()
		defer strings.builder_destroy(&sb)

		for arg in expr {
			value: p.Value
			value, err = execute_expression(arg, scope)
			fmt.sbprint(&sb, value)
		}
		value = strings.clone(strings.to_string(sb)) // TODO: Reference counting of runtime values
	case Value:
		value = expr
	case NameReference:
		variable, _ := s.search_for_reference(scope, expr)
		value = variable.(^s.Variable).contents
	}

	return
}

@(private = "file")
stack := 0

call_function :: proc(
	func_call: p.FunctionCall,
	scope: ^s.Scope,
) -> (
	return_val: p.Value = p.None,
	err: RuntimeError,
) {
	item, _ := s.search_for_reference(scope, func_call.name)

	switch func in item.(s.Function) {
	case s.BuiltInFunction:
		values: [dynamic]p.Value
		defer delete(values)

		for expr in func_call.args {
			arg: p.Value
			arg, err = execute_expression(expr, scope)
			if !is_runtime_error_ok(err) do return
			append(&values, arg)
		}

		return_val, err = func.func_ref(values)
		(&err.(s.FunctionError)).func_name = func_call.name

	case s.InterpretedFunction:
		func_scope := new(s.Scope)
		defer s.destroy_scope(func_scope)
		func_scope.parent_scope = func.parent_scope

		if len(func.args) != len(func_call.args) do return p.None, s.FunctionError{msg = "Incorrect number of arguments passed to function call", func_name = func_call.name}
		for def_arg, i in func.args {
			passed_arg: p.Value
			passed_arg, err = execute_expression(func_call.args[i], scope)
			if !is_runtime_error_ok(err) do return
			if def_arg.type != p.get_value_type(passed_arg) do return p.None, TypeError{msg = "Incorrect function argument type", value1 = def_arg.type, value2 = p.get_value_type(passed_arg)}

			append(&func_scope.constants, s.Variable{def_arg.name, passed_arg, false})
		}

		stack += 1
		if stack > STACK_LIMIT {
			return p.None, StackOverflow(func.name)
		}

		returned: ReturnState
		returned, err = execute_block(func.block, func_scope)
		stack -= 1
		if !is_runtime_error_ok(err) do return
		switch returned.handle_by {
		case .DontHandle: break
		// TODO: do this in evaluation stage
		case .Loop: return p.None, TypeError{msg = "Break attempted outside loop scope"}
		case .Function: return_val = returned.contents.(p.Value)
		}

		// Handle return values
		if p.get_value_type(return_val) != func.return_type {
			err = TypeError {
				msg    = "Function return value does not match return type",
				value1 = p.get_value_type(return_val),
				value2 = func.return_type,
			}
		}
	}
	return
}
