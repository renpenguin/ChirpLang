package execute

import p "../parser"
import s "../scope"
import t "../tokeniser"
import "core:fmt"
import "core:strings"

STACK_LIMIT :: 500

ReturnHandler :: enum {
	DontHandle, // Parent scope can deal with this || no return value
	Loop, // Handle break and continue
	Function, // Handle return
}
ReturnState :: struct {
	handle_by: ReturnHandler,
	contents:  union {
		p.LoopControl, // For .Loop
		p.Value, // For .Function
	},
}
NoReturn :: ReturnState{}

execute_block :: proc(block: p.Block, scope: ^s.Scope) -> (returned := NoReturn, err: RuntimeError = NoErrorUnit) {
	using p

	iter_instructions: for instruction in block {
		switch _ in instruction {
		case VariableDefinition:
			var_def := instruction.(p.VariableDefinition)

			contents: p.Value
			contents, err = execute_expression(var_def.expr, scope)
			if !is_runtime_error_ok(err) do return

			to_assign := s.Variable{var_def.name, contents, var_def.mutable}
			for var, i in scope.constants { 	// Redefining existing variables
				if var.name != var_def.name do continue
				scope.constants[i] = to_assign
				continue iter_instructions
			}
			append(&scope.constants, to_assign)
		case VariableAssignment:
			err = assign_operation(instruction.(p.VariableAssignment), scope)
			if !is_runtime_error_ok(err) do return
		case While:
			while := instruction.(While)
			for {
				result: bool
				result, err = evaluate_condition_expression(while.condition, scope)
				if !is_runtime_error_ok(err) do return
				if !result do break

				while_scope := new(s.Scope)
				defer s.destroy_scope(while_scope)
				while_scope.parent_scope = scope

				while_return, while_err := execute_block(while.block, while_scope)
				if !is_runtime_error_ok(while_err) do return NoReturn, while_err
				if returned.handle_by == .Function do return while_return, while_err
				if while_return.contents == .Break do break
			}
		case IfStatement:
			returned, err = execute_if_statement(instruction.(p.IfStatement), scope)
			if !is_runtime_error_ok(err) do return
			if returned.handle_by != .DontHandle do return
		case Expression:
			_, err = execute_expression(instruction.(Expression), scope)
			if !is_runtime_error_ok(err) do return NoReturn, err
		case Return:
			returned.handle_by = .Function
			returned.contents, err = execute_expression(Expression(instruction.(Return)), scope)
			return
		case LoopControl:
			returned.handle_by = .Loop
			returned.contents = instruction.(LoopControl)
			return

		case ImportStatement, FunctionDefinition:
			break // Ignore
		}
	}

	return
}

@(private)
evaluate_condition_expression :: proc(
	expr: p.Expression,
	scope: ^s.Scope,
) -> (
	result: bool,
	err: RuntimeError = NoErrorUnit,
) {
	condition_value: p.Value
	condition_value, err = execute_expression(expr, scope)
	if !is_runtime_error_ok(err) do return

	is_bool: bool
	result, is_bool = condition_value.(bool)
	return
}

@(private)
execute_if_statement :: proc(
	if_statement: p.IfStatement,
	parent_scope: ^s.Scope,
) -> (
	returned := NoReturn,
	err: RuntimeError = NoErrorUnit,
) {
	result: bool
	result, err = evaluate_condition_expression(if_statement.condition, parent_scope)
	if !is_runtime_error_ok(err) do return

	if result {
		if_scope := new(s.Scope)
		defer s.destroy_scope(if_scope)
		if_scope.parent_scope = parent_scope

		returned, err = execute_block(if_statement.true_block, if_scope) // This writes directly to the return value
	} else {
		switch _ in if_statement.else_branch {
		case ^p.IfStatement:
			returned, err = execute_if_statement(if_statement.else_branch.(^p.IfStatement)^, parent_scope) // So does this

		case p.Block:
			else_scope := new(s.Scope)
			defer s.destroy_scope(else_scope)
			else_scope.parent_scope = parent_scope

			returned, err = execute_block(if_statement.else_branch.(p.Block), else_scope) // and this
		}
	}
	return // Any errors generated by any of the branches will be returned here
}

@(private)
execute_expression :: proc(
	expr: p.Expression,
	scope: ^s.Scope,
) -> (
	value: p.Value = p.None,
	err: RuntimeError = NoErrorUnit,
) {
	using p

	switch _ in expr {
	case FunctionCall:
		return call_function(expr.(p.FunctionCall), scope)
	case Operation:
		op := expr.(p.Operation)

		value1, value2: Value
		value1, err = execute_expression(op.left^, scope)
		if !is_runtime_error_ok(err) do return
		value2, err = execute_expression(op.right^, scope)
		if !is_runtime_error_ok(err) do return

		return process_operation(value1, value2, op.op)
	case FormatString:
		sb := strings.builder_make()
		defer strings.builder_destroy(&sb)

		for arg in expr.(p.FormatString) {
			value: p.Value
			value, err = execute_expression(arg, scope)
			fmt.sbprint(&sb, value)
		}
		value = strings.clone(strings.to_string(sb))
	case Value:
		value = expr.(Value)
	case NameReference:
		name_ref := expr.(NameReference)
		variable, _ := s.search_for_reference(scope, name_ref)

		value = variable.(^s.Variable).contents
	}

	return
}

@(private = "file")
stack := 0

call_function :: proc(
	func_call: p.FunctionCall,
	scope: ^s.Scope,
) -> (
	return_val: p.Value = p.None,
	err: RuntimeError,
) {
	item, _ := s.search_for_reference(scope, func_call.name)
	func := item.(s.Function)

	switch _ in func {
	case s.BuiltInFunction:
		func_pointer := func.(s.BuiltInFunction).func_ref

		values: [dynamic]p.Value
		defer delete(values)

		for expr in func_call.args {
			arg: p.Value
			arg, err = execute_expression(expr, scope)
			if !is_runtime_error_ok(err) do return
			append(&values, arg)
		}

		return_val, err = func_pointer(values)
		(&err.(s.FunctionError)).func_name = func_call.name

	case s.InterpretedFunction:
		interp_func_def := func.(s.InterpretedFunction)

		func_scope := new(s.Scope)
		defer s.destroy_scope(func_scope)
		func_scope.parent_scope = interp_func_def.parent_scope

		if len(interp_func_def.args) != len(func_call.args) do return p.None, s.FunctionError{msg = "Incorrect number of arguments passed to function call", func_name = func_call.name}
		for def_arg, i in interp_func_def.args {
			passed_arg: p.Value
			passed_arg, err = execute_expression(func_call.args[i], scope)
			if !is_runtime_error_ok(err) do return
			if def_arg.type != p.get_value_type(passed_arg) do return p.None, TypeError{msg = "Incorrect function argument type", value1 = def_arg.type, value2 = p.get_value_type(passed_arg)}

			append(&func_scope.constants, s.Variable{def_arg.name, passed_arg, false})
		}

		stack += 1
		if stack > STACK_LIMIT {
			return p.None, StackOverflow(interp_func_def.name)
		}

		returned: ReturnState
		returned, err = execute_block(interp_func_def.block, func_scope)
		stack -= 1
		if !is_runtime_error_ok(err) do return
		switch returned.handle_by {
		case .DontHandle: break
		// TODO: do this in evaluation stage
		case .Loop: return p.None, TypeError{msg = "Break attempted outside loop scope"}
		case .Function: return_val = returned.contents.(p.Value)
		}

		// Handle return values
		if p.get_value_type(return_val) != interp_func_def.return_type {
			err = TypeError {
				msg    = "Function return value does not match return type",
				value1 = p.get_value_type(return_val),
				value2 = interp_func_def.return_type,
			}
		}
	}
	return
}
